# ä»é›¶å¼€å§‹æ„å»º RISC-V CPU

## é¡¹ç›®æ¦‚è¿°

RISC-V æ˜¯ä¸€ä¸ªå¼€æºçš„æŒ‡ä»¤é›†æ¶æ„ï¼ˆISAï¼‰ï¼Œå®ƒä¸ºå¤„ç†å™¨è®¾è®¡æä¾›äº†ä¸€ä¸ªç®€æ´ã€æ¨¡å—åŒ–çš„åŸºç¡€ã€‚æœ¬æ–‡å°†å¸¦ä½ ä»é›¶å¼€å§‹æ„å»ºä¸€ä¸ªç®€å•çš„ RISC-V CPUï¼Œç†è§£å¤„ç†å™¨çš„å·¥ä½œåŸç†ã€‚

## ä¸ºä»€ä¹ˆé€‰æ‹© RISC-Vï¼Ÿ

RISC-V ç›¸æ¯”å…¶ä»–æ¶æ„æœ‰ä»¥ä¸‹ä¼˜åŠ¿ï¼š

| ç‰¹æ€§ | RISC-V | ARM | x86 |
|------|--------|-----|-----|
| å¼€æºæ€§ | âœ… å®Œå…¨å¼€æº | âŒ ä¸“æœ‰ | âŒ ä¸“æœ‰ |
| å¤æ‚åº¦ | ğŸ¯ ç®€æ´ | ğŸ“š ä¸­ç­‰ | ğŸ“šğŸ“š å¤æ‚ |
| å¯æ‰©å±•æ€§ | âœ… æ¨¡å—åŒ– | âš ï¸ å—é™ | âš ï¸ å—é™ |
| å­¦ä¹ æˆæœ¬ | ğŸ’š ä½ | ğŸ’› ä¸­ | ğŸ’” é«˜ |

## RISC-V åŸºç¡€æŒ‡ä»¤é›†

RISC-V çš„åŸºç¡€æ•´æ•°æŒ‡ä»¤é›†ï¼ˆRV32Iï¼‰åŒ…å« 47 æ¡æŒ‡ä»¤ï¼Œåˆ†ä¸ºä»¥ä¸‹å‡ ç±»ï¼š

### 1. ç®—æœ¯è¿ç®—æŒ‡ä»¤

```assembly
# åŠ æ³•
add  x1, x2, x3    # x1 = x2 + x3
addi x1, x2, 100   # x1 = x2 + 100

# å‡æ³•
sub  x1, x2, x3    # x1 = x2 - x3

# é€»è¾‘è¿ç®—
and  x1, x2, x3    # x1 = x2 & x3
or   x1, x2, x3    # x1 = x2 | x3
xor  x1, x2, x3    # x1 = x2 ^ x3
```

### 2. è®¿å­˜æŒ‡ä»¤

```assembly
# åŠ è½½
lw  x1, 0(x2)      # x1 = Memory[x2 + 0]
lb  x1, 4(x2)      # åŠ è½½å­—èŠ‚

# å­˜å‚¨
sw  x1, 0(x2)      # Memory[x2 + 0] = x1
sb  x1, 4(x2)      # å­˜å‚¨å­—èŠ‚
```

### 3. åˆ†æ”¯è·³è½¬æŒ‡ä»¤

```assembly
# æ¡ä»¶åˆ†æ”¯
beq  x1, x2, label # if (x1 == x2) goto label
bne  x1, x2, label # if (x1 != x2) goto label
blt  x1, x2, label # if (x1 < x2) goto label

# æ— æ¡ä»¶è·³è½¬
jal  x1, label     # x1 = PC + 4; goto label
jalr x1, 0(x2)     # x1 = PC + 4; goto x2 + 0
```

## CPU æ¶æ„è®¾è®¡

### äº”çº§æµæ°´çº¿

æˆ‘ä»¬çš„ CPU é‡‡ç”¨ç»å…¸çš„äº”çº§æµæ°´çº¿æ¶æ„ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   IF    â”‚ â†’ â”‚   ID    â”‚ â†’ â”‚   EX    â”‚ â†’ â”‚   MEM   â”‚ â†’ â”‚   WB    â”‚
â”‚ å–æŒ‡ä»¤  â”‚   â”‚ è¯‘ç     â”‚   â”‚ æ‰§è¡Œ    â”‚   â”‚ è®¿å­˜    â”‚   â”‚ å†™å›    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

1. **IF (Instruction Fetch)**: ä»å†…å­˜ä¸­å–æŒ‡ä»¤
2. **ID (Instruction Decode)**: è§£ç æŒ‡ä»¤ï¼Œè¯»å–å¯„å­˜å™¨
3. **EX (Execute)**: æ‰§è¡Œç®—æœ¯/é€»è¾‘è¿ç®—
4. **MEM (Memory Access)**: è®¿é—®æ•°æ®å†…å­˜
5. **WB (Write Back)**: å°†ç»“æœå†™å›å¯„å­˜å™¨

### æ•°æ®é€šè·¯

CPU çš„æ•°æ®é€šè·¯åŒ…å«ä»¥ä¸‹å…³é”®ç»„ä»¶ï¼š

```verilog
// ç¨‹åºè®¡æ•°å™¨
reg [31:0] PC;

// å¯„å­˜å™¨æ–‡ä»¶ï¼ˆ32 ä¸ªå¯„å­˜å™¨ï¼‰
reg [31:0] registers [0:31];

// ALUï¼ˆç®—æœ¯é€»è¾‘å•å…ƒï¼‰
wire [31:0] alu_result;

// æŒ‡ä»¤å†…å­˜å’Œæ•°æ®å†…å­˜
reg [31:0] imem [0:1023];
reg [31:0] dmem [0:1023];
```

## Verilog å®ç°

### 1. æŒ‡ä»¤è§£ç 

```verilog
module decoder(
    input [31:0] instruction,
    output [6:0] opcode,
    output [4:0] rd,
    output [4:0] rs1,
    output [4:0] rs2,
    output [2:0] funct3,
    output [6:0] funct7
);
    assign opcode = instruction[6:0];
    assign rd     = instruction[11:7];
    assign rs1    = instruction[19:15];
    assign rs2    = instruction[24:20];
    assign funct3 = instruction[14:12];
    assign funct7 = instruction[31:25];
endmodule
```

### 2. ALU å®ç°

```verilog
module alu(
    input [31:0] a,
    input [31:0] b,
    input [3:0] alu_op,
    output reg [31:0] result,
    output zero
);
    always @(*) begin
        case (alu_op)
            4'b0000: result = a + b;      // ADD
            4'b0001: result = a - b;      // SUB
            4'b0010: result = a & b;      // AND
            4'b0011: result = a | b;      // OR
            4'b0100: result = a ^ b;      // XOR
            4'b0101: result = a << b[4:0]; // SLL
            4'b0110: result = a >> b[4:0]; // SRL
            4'b0111: result = $signed(a) >>> b[4:0]; // SRA
            default: result = 32'b0;
        endcase
    end
    
    assign zero = (result == 0);
endmodule
```

### 3. å¯„å­˜å™¨æ–‡ä»¶

```verilog
module register_file(
    input clk,
    input we,
    input [4:0] ra1,
    input [4:0] ra2,
    input [4:0] wa,
    input [31:0] wd,
    output [31:0] rd1,
    output [31:0] rd2
);
    reg [31:0] registers [0:31];
    
    // x0 å¯„å­˜å™¨å§‹ç»ˆä¸º 0
    initial begin
        registers[0] = 32'b0;
    end
    
    // å¼‚æ­¥è¯»
    assign rd1 = (ra1 == 0) ? 32'b0 : registers[ra1];
    assign rd2 = (ra2 == 0) ? 32'b0 : registers[ra2];
    
    // åŒæ­¥å†™
    always @(posedge clk) begin
        if (we && wa != 0) begin
            registers[wa] <= wd;
        end
    end
endmodule
```

## æ€§èƒ½åˆ†æ

### CPIï¼ˆæ¯æŒ‡ä»¤å‘¨æœŸæ•°ï¼‰

ç†æƒ³æƒ…å†µä¸‹ï¼Œäº”çº§æµæ°´çº¿çš„ CPI ä¸º 1ã€‚ä½†å®é™…ä¸­ä¼šæœ‰ä»¥ä¸‹å¼€é”€ï¼š

$$
CPI_{actual} = CPI_{ideal} + \text{Stalls}_{data} + \text{Stalls}_{control}
$$

å…¶ä¸­ï¼š
- $CPI_{ideal} = 1$ï¼ˆç†æƒ³æµæ°´çº¿ï¼‰
- $\text{Stalls}_{data}$ï¼šæ•°æ®å†’é™©å¯¼è‡´çš„åœé¡¿
- $\text{Stalls}_{control}$ï¼šæ§åˆ¶å†’é™©å¯¼è‡´çš„åœé¡¿

### æ—¶é’Ÿé¢‘ç‡

å¤„ç†å™¨çš„æœ€å¤§æ—¶é’Ÿé¢‘ç‡å—é™äºæœ€é•¿çš„å…³é”®è·¯å¾„ï¼š

$$
f_{max} = \frac{1}{T_{critical}}
$$

å¯¹äºäº”çº§æµæ°´çº¿ï¼š

$$
T_{critical} = \max(T_{IF}, T_{ID}, T_{EX}, T_{MEM}, T_{WB})
$$

## å†’é™©å¤„ç†

### æ•°æ®å†’é™©

å½“åç»­æŒ‡ä»¤ä¾èµ–å‰é¢æŒ‡ä»¤çš„ç»“æœæ—¶ï¼Œä¼šäº§ç”Ÿæ•°æ®å†’é™©ï¼š

```assembly
add x1, x2, x3    # x1 = x2 + x3
sub x4, x1, x5    # ä¾èµ– x1ï¼ˆæ•°æ®å†’é™©ï¼‰
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. **å‰é€’ï¼ˆForwardingï¼‰**ï¼šå°† EX/MEM æˆ– MEM/WB é˜¶æ®µçš„ç»“æœç›´æ¥ä¼ é€’ç»™ EX é˜¶æ®µ
2. **åœé¡¿ï¼ˆStallingï¼‰**ï¼šåœ¨æ— æ³•å‰é€’æ—¶æ’å…¥æ°”æ³¡

### æ§åˆ¶å†’é™©

åˆ†æ”¯æŒ‡ä»¤ä¼šå¯¼è‡´æ§åˆ¶å†’é™©ï¼š

```assembly
beq x1, x2, target
add x3, x4, x5    # å¯èƒ½è¢«é”™è¯¯æ‰§è¡Œ
```

**è§£å†³æ–¹æ¡ˆ**ï¼š
1. **åˆ†æ”¯é¢„æµ‹**ï¼šé¢„æµ‹åˆ†æ”¯æ–¹å‘
2. **å»¶è¿Ÿæ§½**ï¼šåœ¨åˆ†æ”¯æŒ‡ä»¤åæ‰§è¡Œä¸€æ¡æ— å…³æŒ‡ä»¤
3. **æ¸…ç©ºæµæ°´çº¿**ï¼šåœ¨åˆ†æ”¯è·³è½¬æ—¶æ¸…ç©ºåç»­æŒ‡ä»¤

## æµ‹è¯•ç¨‹åº

### æ–æ³¢é‚£å¥‘æ•°åˆ—

```assembly
# è®¡ç®—æ–æ³¢é‚£å¥‘æ•°åˆ—çš„ç¬¬ n é¡¹
# x10 = n, x11 = result

fibonacci:
    li   x11, 1          # f(0) = 1
    li   x12, 1          # f(1) = 1
    li   x13, 2          # counter = 2
    
loop:
    bge  x13, x10, done  # if counter >= n, done
    add  x14, x11, x12   # temp = f(n-1) + f(n-2)
    mv   x11, x12        # f(n-2) = f(n-1)
    mv   x12, x14        # f(n-1) = temp
    addi x13, x13, 1     # counter++
    j    loop
    
done:
    mv   x11, x12        # result = f(n)
    ret
```

## ä»¿çœŸä¸éªŒè¯

ä½¿ç”¨ Verilator è¿›è¡Œä»¿çœŸï¼š

```cpp
#include "Vcpu.h"
#include "verilated.h"

int main(int argc, char** argv) {
    Verilated::commandArgs(argc, argv);
    Vcpu* cpu = new Vcpu;
    
    // åˆå§‹åŒ–
    cpu->clk = 0;
    cpu->rst = 1;
    cpu->eval();
    
    // é‡Šæ”¾å¤ä½
    cpu->rst = 0;
    
    // è¿è¡Œ 1000 ä¸ªæ—¶é’Ÿå‘¨æœŸ
    for (int i = 0; i < 1000; i++) {
        cpu->clk = !cpu->clk;
        cpu->eval();
    }
    
    delete cpu;
    return 0;
}
```

## FPGA éƒ¨ç½²

### èµ„æºä½¿ç”¨

åœ¨ Xilinx Artix-7 FPGA ä¸Šçš„èµ„æºä½¿ç”¨ï¼š

| èµ„æºç±»å‹ | ä½¿ç”¨é‡ | å¯ç”¨é‡ | åˆ©ç”¨ç‡ |
|---------|--------|--------|--------|
| LUT | 2,456 | 63,400 | 3.87% |
| FF | 1,234 | 126,800 | 0.97% |
| BRAM | 8 | 135 | 5.93% |
| DSP | 0 | 240 | 0% |

### æ—¶åºåˆ†æ

- **æœ€å¤§æ—¶é’Ÿé¢‘ç‡**: 125 MHz
- **å…³é”®è·¯å¾„å»¶è¿Ÿ**: 8 ns
- **æ—¶åºè£•é‡**: 2 ns

## æ‰©å±•åŠŸèƒ½

### 1. ä¹˜é™¤æ³•æŒ‡ä»¤ï¼ˆM æ‰©å±•ï¼‰

```verilog
module multiplier(
    input [31:0] a,
    input [31:0] b,
    output [31:0] product
);
    assign product = a * b;
endmodule
```

### 2. æµ®ç‚¹è¿ç®—ï¼ˆF æ‰©å±•ï¼‰

å®ç° IEEE 754 å•ç²¾åº¦æµ®ç‚¹è¿ç®—ã€‚

### 3. ç¼“å­˜ç³»ç»Ÿ

æ·»åŠ  L1 æŒ‡ä»¤ç¼“å­˜å’Œæ•°æ®ç¼“å­˜ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ I-Cache â”‚     â”‚ D-Cache â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
     â”‚               â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
        â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
        â”‚   L2    â”‚
        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
             â”‚
        â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
        â”‚  Memory â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## æ€§èƒ½ä¼˜åŒ–

### 1. è¶…æ ‡é‡æ‰§è¡Œ

åŒæ—¶å‘å°„å¤šæ¡æŒ‡ä»¤ï¼š

$$
IPC = \frac{\text{Instructions}}{\text{Cycles}} > 1
$$

### 2. ä¹±åºæ‰§è¡Œ

å…è®¸æŒ‡ä»¤åœ¨æ•°æ®å°±ç»ªæ—¶æ‰§è¡Œï¼Œè€Œä¸å¿…æŒ‰é¡ºåºæ‰§è¡Œã€‚

### 3. åˆ†æ”¯é¢„æµ‹

ä½¿ç”¨ä¸¤ä½é¥±å’Œè®¡æ•°å™¨è¿›è¡Œåˆ†æ”¯é¢„æµ‹ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”  é¢„æµ‹é”™è¯¯  â”Œâ”€â”€â”€â”€â”€â”
â”‚ 00  â”‚ â†â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚ 01  â”‚
â””â”€â”€â”¬â”€â”€â”˜            â””â”€â”€â”¬â”€â”€â”˜
   â”‚                  â”‚
   â”‚ é¢„æµ‹æ­£ç¡®         â”‚ é¢„æµ‹é”™è¯¯
   â”‚                  â”‚
â”Œâ”€â”€â”´â”€â”€â”            â”Œâ”€â”€â”´â”€â”€â”
â”‚ 10  â”‚ â†â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚ 11  â”‚
â””â”€â”€â”€â”€â”€â”˜  é¢„æµ‹æ­£ç¡®  â””â”€â”€â”€â”€â”€â”˜
```

## è°ƒè¯•æŠ€å·§

### 1. æ³¢å½¢æŸ¥çœ‹

ä½¿ç”¨ GTKWave æŸ¥çœ‹ä»¿çœŸæ³¢å½¢ï¼š

```bash
gtkwave cpu.vcd
```

### 2. æ‰“å°è°ƒè¯•ä¿¡æ¯

```verilog
always @(posedge clk) begin
    $display("PC=%h, Inst=%h, ALU=%h", PC, instruction, alu_result);
end
```

### 3. æ–­è¨€æ£€æŸ¥

```verilog
always @(posedge clk) begin
    if (registers[0] != 0) begin
        $error("x0 register is not zero!");
        $finish;
    end
end
```

## æ€»ç»“

é€šè¿‡æœ¬é¡¹ç›®ï¼Œæˆ‘ä»¬å­¦ä¹ äº†ï¼š

1. **RISC-V æŒ‡ä»¤é›†æ¶æ„**ï¼šç®€æ´ã€æ¨¡å—åŒ–çš„è®¾è®¡ç†å¿µ
2. **CPU å¾®æ¶æ„**ï¼šäº”çº§æµæ°´çº¿çš„å·¥ä½œåŸç†
3. **Verilog ç¡¬ä»¶æè¿°è¯­è¨€**ï¼šæ•°å­—ç”µè·¯çš„å®ç°æ–¹æ³•
4. **å†’é™©å¤„ç†**ï¼šæ•°æ®å†’é™©å’Œæ§åˆ¶å†’é™©çš„è§£å†³æ–¹æ¡ˆ
5. **æ€§èƒ½ä¼˜åŒ–**ï¼šè¶…æ ‡é‡ã€ä¹±åºæ‰§è¡Œã€åˆ†æ”¯é¢„æµ‹ç­‰æŠ€æœ¯

æ„å»º CPU æ˜¯ç†è§£è®¡ç®—æœºç³»ç»Ÿçš„æœ€ä½³æ–¹å¼ã€‚ä»ç®€å•çš„å•å‘¨æœŸ CPU å¼€å§‹ï¼Œé€æ­¥æ·»åŠ æµæ°´çº¿ã€ç¼“å­˜ã€åˆ†æ”¯é¢„æµ‹ç­‰åŠŸèƒ½ï¼Œä½ å°†æ·±å…¥ç†è§£å¤„ç†å™¨çš„å·¥ä½œåŸç†ã€‚

## å‚è€ƒèµ„æº

- [RISC-V å®˜æ–¹è§„èŒƒ](https://riscv.org/specifications/)
- [ã€Šè®¡ç®—æœºç»„æˆä¸è®¾è®¡ï¼šRISC-V ç‰ˆã€‹](https://www.elsevier.com/books/computer-organization-and-design-risc-v-edition/patterson/978-0-12-812275-4)
- [Chisel ç¡¬ä»¶æ„é€ è¯­è¨€](https://www.chisel-lang.org/)
- [Rocket Chip Generator](https://github.com/chipsalliance/rocket-chip)

_æœ€åæ›´æ–°ï¼š2024-12-05_
